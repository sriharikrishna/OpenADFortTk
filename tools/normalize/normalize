#! /usr/bin/env perl
# -*-Mode: perl;-*-

# make sure we execute perl
#eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
#& eval 'exec perl -S $0 $argv:q'
#if 0;

## $Id: normalize,v 1.1 2004/02/11 14:44:23 eraxxon Exp $
## * BeginRiceCopyright *****************************************************
## ******************************************************* EndRiceCopyright *

#############################################################################
##
## $Source: /Volumes/cvsrep/developer/OpenADFortTk/tools/normalize/normalize,v $ 
##
##   Nathan Tallent.
##
#############################################################################

use strict;
use IO::File;
#use File::Temp; # not widely available
STDOUT->autoflush(1); 

my $usage = 
"usage: normalize <xaif-file_1>...<xaif-file_n>

Given a list of files, normalize them.
  XAIF (*.xaif):
    - remove any timestamps
\n";

my $version = "1.0";

#############################################################################
## main/driver
#############################################################################

# ----------------------------------------------------------
# Parse the command line
# ----------------------------------------------------------

## Make sure called with minimum number of arguments
my $numArgs = scalar(@ARGV);
if ($numArgs < 1) { die $usage; }

my $theFiles = [ ];

my $fileidx = 0;

for ( ; $fileidx < $numArgs; $fileidx++) {
    my $file = $ARGV[$fileidx]; 
    if (! (-r $file)) {
	print STDERR "*** Cannot read file '$file' ***\n"; 
	printUsageAndExit($0);
    } 
    
    push @$theFiles, $file;
}

# ----------------------------------------------------------
# 
# ----------------------------------------------------------

foreach my $file (@{$theFiles}) {
    normalize($file);    
}

exit(0);

#############################################################################
## Subroutines
#############################################################################

# printUsageAndExit
sub printUsageAndExit 
{
    my ($command) = @_; # not used now
    print STDOUT ${usage};
    exit(-1);
}

# printVersionAndExit
sub printVersionAndExit 
{
    my ($command) = @_; # not used now
    print STDERR "normalize: ", $version, "\n";
    exit(-1);
}


#############################################################################
## normalize
#############################################################################

# normalize: Given a file, normalize it
# returns: 
# effect: 
# assumes: The file is readable.
sub normalize
{
    my($file) = @_;
  
    # ----------------------------------------------------------
    # normalize timestamp references
    # ----------------------------------------------------------
    my $w2x_ts_RE = 'XAIF file translated from WHIRL at .+ --';
    my $w2x_ts    = 'XAIF file translated from WHIRL at XXX --';

    normalizeTimestamps($file, $w2x_ts_RE, $w2x_ts);
    
    return 0;
}


# normalizeTimestamps: Given a filename (that should exist), a
# timestamp regexp and a normalized timestamp, replace all instances
# of the former with the latter. Returns 0 on success.
sub normalizeTimestamps
{
    my($file, $timestampRE, $timestampNorm) = @_;
    my $line = undef;
    
    # Open/prepare files
    my $fh = new IO::File;
    $fh->open("< $file") 
	or die "Error! Can't open '$file'\n";    
    my ($tmpfh, $tmpfn) = getTempFile();

    # Copy lines up to timestamp
    while ($line = <$fh>) {
	if ($line =~ /$timestampRE/) {
	    # Normalize timestamp
	    $line =~ s/$timestampRE/$timestampNorm/;
	} 
	print $tmpfh $line;
    }
    
    # Cleanup
    $fh->close();
    $tmpfh->close();
    rename($tmpfn, $file)
	or die "Error! Can't rename $tmpfn -> $file: $!\n";
    
    return 0;
}


sub getTempFile()
{
    # We would like to use:
    # File::Temp
    # ($fh, $filename) = tempfile( DIR => $dir );
    my $filename = "normalize.tmp.$$~";
    my $fh = new IO::File;
    $fh->open("> $filename") 
	or die "Error! Can't open '$filename'\n";
    return ($fh, $filename);
}
