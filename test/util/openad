#! /usr/bin/env perl
# -*-Mode: perl;-*-

# make sure we execute perl
#eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
#& eval 'exec perl -S $0 $argv:q'
#if 0;

#############################################################################
##
##   Nathan Tallent.
##
#############################################################################

use strict;
use warnings;
use File::Spec;
use IO::File;
use Getopt::Long;

STDOUT->autoflush(1); 

my $the_program = $0;
my $the_usage = 
"usage: ${the_program} [mode] [options] <fortran-file>

Mode:
  --bb-rev          BasicBlockPreaccumulationReverse [Default]
  --bb-tapeadj      BasicBlockPreaccumulationTapeAdjoint
  --bb-tape         BasicBlockPreaccumulationTape
  --bb              BasicBlockPreaccumulation
  --cfr             ControlFlowReversal
  --linear          Linearization
  --memopstradeoff  MemOpsTradeoffPreaccumulation

Options:
  -i, --interactive  
    prompt user to authorize each step in pipeline
  -v [lvl], --verbose [lvl]
    Set verbosity level.  If no level is supplied, defaults to 1.
    1: 
    2: Print all pipeline commands
  -h, --help         print help
\n";

#############################################################################

my ($alg_BasicBlockPreaccumulationReverse,
    $alg_BasicBlockPreaccumulationTapeAdjoint,
    $alg_BasicBlockPreaccumulationTape,
    $alg_BasicBlockPreaccumulation,
    $alg_ControlFlowReversal,
    $alg_Linearization,
    $alg_MemOpsTradeoffPreaccumulation) =
    (1, 2, 3, 4, 5, 6, 7);

#############################################################################
## main/driver
#############################################################################

my @options = ('bb-rev',
	       'bb-tapeadj',
	       'bb-tape',
	       'bb',
	       'cfr',
	       'linear',
	       'memopstradeoff',
	       
	       'interactive|i',
	       'verbose|v:i',
	       'help|h');

my $opt_interactive = undef;
my $opt_verbose = 0;
#my $opt_debug = 0;
my $openad_mode = undef;
my $openad_input = undef;

# ----------------------------------------------------------
# Parse the command line
# ----------------------------------------------------------

# Get optional arguments
my %opts = ();
my $ret = GetOptions(\%opts, @options);
if (!$ret) { 
  printErrorAndExit(); 
}

# Get optional arguments: verbose, help
if (defined($opts{'verbose'})) {
  $opt_verbose = $opts{'verbose'};
  if ($opt_verbose == 0) { $opt_verbose = 1; }
} 
if (defined($opts{'help'})) {
  printUsageAndExit($the_program);
} 

# Get required argument: OpenAD Mode
$openad_mode = $alg_BasicBlockPreaccumulationReverse;
if (defined($opts{'bb-rev'})) {
  $openad_mode = $alg_BasicBlockPreaccumulationReverse;
} 
if (defined($opts{'bb-tapeadj'})) {
  $openad_mode = $alg_BasicBlockPreaccumulationTapeAdjoint;
} 
if (defined($opts{'bb-tape'})) {
  $openad_mode = $alg_BasicBlockPreaccumulationTape;
} 
if (defined($opts{'bb'})) {
  $openad_mode = $alg_BasicBlockPreaccumulation;
} 
if (defined($opts{'cfr'})) {
  $openad_mode = $alg_ControlFlowReversal;
} 
if (defined($opts{'linear'})) {
  $openad_mode = $alg_Linearization;
} 
if (defined($opts{'memopstradeoff'})) {
  $openad_mode = $alg_MemOpsTradeoffPreaccumulation;
} 
if (!defined($openad_mode)) {
  printUsageAndExit($the_program);
}

# Get optional arguments: interactive
if (defined($opts{'interactive'})) {
  $opt_interactive = 1;
} 


# Get required arguments
my $numArgs = scalar(@ARGV);
if ($numArgs != 1) { 
  printErrorAndExit("Invalid number of required arguments!\n"); 
}

$openad_input = $ARGV[0];

# ----------------------------------------------------------
# Run
# ----------------------------------------------------------

RunOpenADPipeline($openad_mode, $openad_input);

#############################################################################
## Subroutines
#############################################################################

# printUsageAndExit
sub printUsageAndExit 
{
  my ($command) = @_; # not used now
  print STDOUT ${the_usage};
  exit(-1);
}

# printErrorAndExit
sub printErrorAndExit 
{
  my ($msg) = @_;
  if (defined($msg)) {
    print STDOUT "${msg}";
  }
  print STDOUT "Try `${the_program} --help' for more information.\n";
  exit(-1);
}

# printUsageAndExit
sub undefEnvVarErr 
{
  my ($var) = @_;
  print STDOUT "Undefined environment variable '${var}'\n";
  exit(-1);
}


#############################################################################
## Subroutines
#############################################################################

# RunOpenADPipeline:
{
  my $configured = undef;
  my ($MFEF90, $WHIRL2F) = (undef, undef);
  my ($W2X, $X2W, $NORM, $PP) = (undef, undef, undef, undef);
  my ($XB) = (undef);
  
  my ($WHIRL2XAIF, $PLATFORM, $OPEN64) = (undef, undef, undef);
  my $XAIFBOOSTERROOT = undef;
  my $XAIFSCHEMAROOT = undef;
  
  my $f_RE = undef;
  my $F_RE = undef;
  my $f90_RE = undef;

  sub RunOpenADPipeline 
  {
    my($mode, $fortranfile) = @_;
    
    # Use this instead of a BEGIN block so we can pass options
    if (!defined($configured)) {
      ConfigRunOpenADPipeline($mode);
    }
    
    # Find base name of file. Support following extensions: .f90, .f, .F
    my $base = $fortranfile;
    my $num = ($base =~ s/(?:$f90_RE)|(?:$f_RE)|(?:$F_RE)//); 
    if ($num == 0) {
      print STDOUT "Unknown file type: ${fortranfile}\n";
      exit(-1);
    }
    
    if ($opt_verbose >= 1) {
      print STDOUT "OpenAD: ${fortranfile} --> ${base}.xb.x2w.w2f.pp.f\n";
    }
    #print STDOUT "$XB\n";

    my $cmdsRef = 
	["$MFEF90  ${fortranfile}",
	 "$W2X     ${base}.B -o ${base}.xaif",
	 "$NORM    ${base}.xaif",
	 "$XB   -i ${base}.xaif -o ${base}.xb.xaif",
	 "$X2W --st ${base}.B ${base}.xb.xaif -o ${base}.xb.x2w.B",
	 "$WHIRL2F ${base}.xb.x2w.B",
	 "$NORM    ${base}.xb.x2w.w2f.f",
	 "$PP      ${base}.xb.x2w.w2f.f"];
    
    RunCmds($cmdsRef, $opt_verbose, $opt_interactive);
  }

  sub ConfigRunOpenADPipeline 
  {
    my($mode) = @_;
    
    $WHIRL2XAIF = $ENV{WHIRL2XAIF};
    if (!defined($WHIRL2XAIF)) { undefEnvVarErr('WHIRL2XAIF'); }
    
    $PLATFORM = $ENV{WHIRL2XAIF_PLATFORM};
    if (!defined($PLATFORM)) { undefEnvVarErr('WHIRL2XAIF_PLATFORM'); }
    
    $OPEN64 = $ENV{WHIRL2XAIF_OPEN64};
    if (!defined($OPEN64)) { undefEnvVarErr('WHIRL2XAIF_OPEN64'); }
    
    $XAIFBOOSTERROOT = $ENV{XAIFBOOSTERROOT};
    if (!defined($XAIFBOOSTERROOT)) { undefEnvVarErr('XAIFBOOSTERROOT'); }
    
    $XAIFSCHEMAROOT = $ENV{XAIFSCHEMAROOT};
    if (!defined($XAIFSCHEMAROOT)) { undefEnvVarErr('XAIFSCHEMAROOT'); }
    
    $MFEF90  = "${OPEN64}/crayf90/sgi/mfef90";
    $WHIRL2F = "${OPEN64}/whirl2f/whirl2f";
    
    $W2X  = "${WHIRL2XAIF}/obj/${PLATFORM}/obj/whirl2xaif";
    $X2W  = "${WHIRL2XAIF}/obj/${PLATFORM}/obj/xaif2whirl";
    $NORM = "${WHIRL2XAIF}/test/util/normalize";
    $PP   = "perl ${WHIRL2XAIF}/postprocess/pp.pl";
    
    my $XB_alg_path = "${XAIFBOOSTERROOT}/xaifBooster/algorithms";
    my $XB_alg = undef;
    if ($mode == $alg_BasicBlockPreaccumulationReverse) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulationReverse/test/t";
    } 
    elsif ($mode == $alg_BasicBlockPreaccumulationTapeAdjoint) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulationTapeAdjoint/test/t";
    } 
    elsif ($mode == $alg_BasicBlockPreaccumulationTape) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulationTape/test/t";
    }
    elsif ($mode == $alg_BasicBlockPreaccumulation) {
      $XB_alg = "${XB_alg_path}/BasicBlockPreaccumulation/test/t";
    }
    elsif ($mode == $alg_ControlFlowReversal) {
      $XB_alg = "${XB_alg_path}/ControlFlowReversal/test/t";
    }
    elsif ($mode == $alg_Linearization) {
      $XB_alg = "${XB_alg_path}/Linearization/test/t";
    }
    elsif ($mode == $alg_MemOpsTradeoffPreaccumulation) {
      $XB_alg = "${XB_alg_path}/MemOpsTradeoffPreaccumulation/test/t";
    } 
    else {
      printErrorAndExit("Internal Error: invalid algorithm");
    }
    
    my $ii_xaif = "$XAIFSCHEMAROOT/schema/examples/inlinable_intrinsics.xaif";
    if ($PLATFORM eq "i686-Cygwin") {
      # convert to Windows path for XercesC
      $ii_xaif = "\`cygpath -w ${ii_xaif}\`";
    } 
    
    $XB = "${XB_alg} -c ${ii_xaif}";
    
    $f_RE = '.f$';
    $F_RE = '.F$';
    $f90_RE = '.f90$';

    ConfigSchema();

    $configured = 1;
  }

  sub ConfigSchema 
  {
    # Check if files already exist
    my @schemafiles = glob("xaif*.xsd");
    if (scalar(@schemafiles) > 0) {
      return;
    }
    
    # Link files
    @schemafiles = glob("${XAIFSCHEMAROOT}/schema/xaif*.xsd");
    for my $path (@schemafiles) {
      my ($vol,$dir,$file) = File::Spec->splitpath($path);
      if (${PLATFORM} eq "i686-Cygwin") {
	link($path, "./$file") or die "Error: could not link $path";
      } else {
	symlink($path, "./$file") or die "Error: could not link $path"
      }
    }
  }

  sub RunCmds
  {
    my($cmdsRef, $verbose, $interactive) = @_;
    
    for my $cmd (@{$cmdsRef}) {
      if ($interactive) {
	print STDOUT "OpenAD: Execute? '${cmd}'\n";
	print STDOUT "...[Y/n]\n";
	my $ans = <STDIN>;
	chomp($ans);
	if (defined($ans) && ($ans eq 'n' || $ans eq 'N')) {
	  last;
	}
      }
      RunCmd($cmd, $verbose); 
    }
    
  }

  sub RunCmd
  {
    my($cmd, $verbose) = @_;

    my $outfile = "./OpenAD-out.tmp~";
    $cmd .= " > ${outfile} 2>&1";

    if ($verbose >= 2) {
      print STDOUT "OpenAD: Executing '${cmd}'\n";
    }

    if (system($cmd) != 0) {
      my $exit_value  = $? >> 8;
      my $signal_num  = $? & 127;
      my $dumped_core = $? & 128;  
      print STDERR "*** OpenAD failure (exit: $exit_value) ***\n";
      print STDERR "$cmd\n";
      system("cat ${outfile}");
      exit(-1);
    } else {
      unlink($outfile);
    }
  }
}

#############################################################################

# Local Variables:
# perl-indent-level: 2
# End:
